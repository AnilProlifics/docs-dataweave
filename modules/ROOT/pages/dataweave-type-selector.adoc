= Type Selector
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

Using the dot selector (`.`) over DataWeave xref:dataweave-type-system.adoc#composite-types[types] enables you to declare new types from existing ones. Combined with the xref:dataweave-selectors-reusing-types.adoc[module loader], DataWeave can also load and translate declarations from a custom module file into DataWeave type directives that can be accessed in the same way as types from any other DataWeave module.

== Example: Declaring a New Type from an Existing Type
The following example declares the `NameType` from the `User` type. Using the dot selector in `User.name` to declare the `name` variable a `NameType` enables the `typeOf()`  function to return the basic type, `"String"`. Notice how the DataWeave variable `name` is declared as a `NameType` value "Seba".

.DataWeave script:
[source,dataweave,linenums]
----
%dw 2.0
type User = {name: String}
type NameType = User.name
var name: NameType = "Seba"
---
typeOf(name)
----

.Output: 
----
"String"
----

== Use the Dot Selector (`.`) Over DataWeave Types

=== Composition
The following example uses the dot selector (`.`) to declare a new type `Address` from one key in the complex type `User`.

.DataWeave script:
[source,dataweave,linenums]
----
%dw 2.0
output application/json
type User = {
 address : {country: String, city: String, street: String, number: Number},
 userName : String
}
type Address = User.address

var userAddress: Address = {country: "Argentina", city: "Rosario", street: "Calle Falsa", number: 123}
---
userAddress
----

.Output:
[source,json,linenums]
----
{
 "country": "Argentina",
 "city": "Rosario",
 "street": "Calle Falsa",
 "number": 123
}
----

=== Union Types
The next example shows how type selection can also be used with `Union` types that consist of `Object` types:

.DataWeave script:
[source,dataweave,linenums]
----
%dw 2.0
output application/json
type ID = {name: String} | {id: Number}
var name: ID = {name: "Seba"}
var id: ID = {id: 38123}
var nameString: ID.name = "Seba"
var idNumber: ID.id = 38123
---
[name, id, nameString ++ " is of type " ++ typeOf(nameString), idNumber ++ " is of type " ++ typeOf(idNumber)]
----

.Output:
[source,json,linenums]
----
[
  {
    "name": "Seba"
  },
  {
    "id": 38123
  },
  "Seba is of type String",
  "38123 is of type Number"
]
----

However, the following script fails because the second type is not an `Object` type and there is no way to reference it with the selector:

.DataWeave script:
[source,dataweave,linenums]
----
%dw 2.0
output application/json
type UnionType = {name: String} | Number
type Fail = UnionType.name
---
{}
----

.Output:
[source,json,linenums]
----
Cannot do selection on Type: Number

4| type Fail = UnionType.name
----

=== Namespace
The following example shows type selection of a namespace:

.DataWeave script:
[source,dataweave,linenums]
----
%dw 2.0
output application/json
ns ns1 http://acme.com
type User = {
 ns1#name : String,
 name : Number,
}
var nameString: User.ns1#name = "Seba"
var nameNumber: User.name = 123
---
{
   "NameString" : typeOf(nameString),
   "NameNumber" : typeOf(nameNumber)
}
----

.Output:
[source,json,linenums]
----
{
 "NameString": "String",
 "NameNumber": "Number"
}
----

=== Metadata
This example outlines how type selection preserves metadata associated with the type:

.DataWeave script:
[source,dataweave,linenums]
----
%dw 2.0
output application/json
type User = {
 birthDate: Date {format: "dd-MMM-yy"},
 userName : String {schema: "value"}
}
type FormattedDate = User.birthDate
type UserName = User.userName
var formattedDate: FormattedDate = "10-SEP-15" as Date {format: "dd-MMM-yy"}
var otherFormatDate = "23-10-2022" as Date {format: "dd-MM-yyyy"}
var userName = "Messi" as String {schema: "value"}
var otherUserName = "Di Mar√≠a" as String {schema: "otherValue"}
---
{
formattedDate: formattedDate is FormattedDate,
userName: userName is UserName,
otherFormatDate: otherFormatDate is FormattedDate,
otherUserName: otherUserName is UserName
}
----

.Output:
[source,json,linenums]
----
{
 "formattedDate": true,
 "userName": true,
 "otherFormatDate": false,
 "otherUserName": false
}
----

=== Generics
This example shows type selection with generics:

.DataWeave script:
[source,dataweave,linenums]
----
%dw 2.0
output application/json
type WithParameters<A, B> = {first: A, second: B, nestedObject: {message: A}}
---
{
 a: true is WithParameters<Boolean, Number>.first,
 b: 4592 is WithParameters<String, Number>.second,
 c: "sdf" is WithParameters<String, Number>.nestedObject.message,
}
----

.Output:
[source,json,linenums]
----
{
 a: true is WithParameters<Boolean, Number>.first,
 b: 4592 is WithParameters<String, Number>.second,
 c: "sdf" is WithParameters<String, Number>.nestedObject.message,
}
----